<html> 

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <title>GRAPH/GRAPH - simple graph data structure and algorithms</title>
  <style type="text/css">
  pre { padding:5px; background-color:#e0e0e0 }
  h3, h4 { text-decoration: underline; }
  a { text-decoration: none; padding: 1px 2px 1px 2px; }
  a:visited { text-decoration: none; padding: 1px 2px 1px 2px; }
  a:hover { text-decoration: none; padding: 1px 1px 1px 1px; border: 1px solid #000000; } 
  a:focus { text-decoration: none; padding: 1px 2px 1px 2px; border: none; }
  a.none { text-decoration: none; padding: 0; }
  a.none:visited { text-decoration: none; padding: 0; } 
  a.none:hover { text-decoration: none; border: none; padding: 0; } 
  a.none:focus { text-decoration: none; border: none; padding: 0; } 
  a.noborder { text-decoration: none; padding: 0; } 
  a.noborder:visited { text-decoration: none; padding: 0; } 
  a.noborder:hover { text-decoration: none; border: none; padding: 0; } 
  a.noborder:focus { text-decoration: none; border: none; padding: 0; }  
  pre.none { padding:5px; background-color:#ffffff }
  </style>
</head>

<body bgcolor=white>

<h2> GRAPH/GRAPH - simple graph data structure and algorithms</h2>

<br>&nbsp;<br><h3><a name=abstract class=none>Abstract</a></h3>

<p>The GRAPH library strives for simplicity both in backing data
       structures and in usage.  Graphs and Digraphs are represented
       as CLOS objects with methods and algorithms provided for graph
       manipulation and analysis.

       </p><p>See the <a href="json.html">GRAPH/JSON</a> and
       <a href="dot.html">GRAPH/DOT</a> libraries for
       serialization and visualization of graphs.

       </p><p><em>Note</em>: currently this
       library is only supported on SBCL and Clozure CL because of the
       need to create hashes with custom equality tests, however
       <em>many</em> other lisps support this so extending should be
       simple.  Patches welcome.</p>

The code is available under the <a
href="http://www.gnu.org/licenses/gpl-3.0.html">GNU General Public License</a>.

<p>
<font color=red>Source:</font>
<a href="http://github.com/eschulte/graph">http://github.com/eschulte/graph</a>.

<br>&nbsp;<br><h3><a class=none name="contents">Contents</a></h3>
<ol>
  <li><a href="#source">Source</a></li>
  <li><a href="#introduction">Introduction</a></li>
  <li><a href="#dictionary">The GRAPH/GRAPH dictionary</a></li>
    <ol>
      <li><a href="#add-edge"><code>add-edge</code></a></li>
      <li><a href="#add-node"><code>add-node</code></a></li>
      <li><a href="#add-paths"><code>add-paths</code></a></li>
      <li><a href="#basic-cycles"><code>basic-cycles</code></a></li>
      <li><a href="#betweenness"><code>betweenness</code></a></li>
      <li><a href="#cliques"><code>cliques</code></a></li>
      <li><a href="#closedp"><code>closedp</code></a></li>
      <li><a href="#closeness"><code>closeness</code></a></li>
      <li><a href="#clustering-coefficient"><code>clustering-coefficient</code></a></li>
      <li><a href="#connected-component"><code>connected-component</code></a></li>
      <li><a href="#connected-components"><code>connected-components</code></a></li>
      <li><a href="#connected-groups-of-size"><code>connected-groups-of-size</code></a></li>
      <li><a href="#connectedp"><code>connectedp</code></a></li>
      <li><a href="#copy"><code>copy</code></a></li>
      <li><a href="#cycles"><code>cycles</code></a></li>
      <li><a href="#degeneracy"><code>degeneracy</code></a></li>
      <li><a href="#degree"><code>degree</code></a></li>
      <li><a href="#delete-edge"><code>delete-edge</code></a></li>
      <li><a href="#delete-node"><code>delete-node</code></a></li>
      <li><a href="#digraph"><code>digraph</code></a></li>
      <li><a href="#digraph-of"><code>digraph-of</code></a></li>
      <li><a href="#edgar-gilbert-digraph"><code>edgar-gilbert-digraph</code></a></li>
      <li><a href="#edgar-gilbert-graph"><code>edgar-gilbert-graph</code></a></li>
      <li><a href="#edgar-gilbert-populate"><code>edgar-gilbert-populate</code></a></li>
      <li><a href="#edge-neighbors"><code>edge-neighbors</code></a></li>
      <li><a href="#edge-value"><code>edge-value</code></a></li>
      <li><a href="#edges"><code>edges</code></a></li>
      <li><a href="#edges-w-values"><code>edges-w-values</code></a></li>
      <li><a href="#erdos-renyi-digraph"><code>erdos-renyi-digraph</code></a></li>
      <li><a href="#erdos-renyi-graph"><code>erdos-renyi-graph</code></a></li>
      <li><a href="#erdos-renyi-populate"><code>erdos-renyi-populate</code></a></li>
      <li><a href="#farness"><code>farness</code></a></li>
      <li><a href="#from-plist"><code>from-plist</code></a></li>
      <li><a href="#from-value-matrix"><code>from-value-matrix</code></a></li>
      <li><a href="#graph"><code>graph</code></a></li>
      <li><a href="#graph-equal"><code>graph-equal</code></a></li>
      <li><a href="#graph-of"><code>graph-of</code></a></li>
      <li><a href="#has-edge-p"><code>has-edge-p</code></a></li>
      <li><a href="#has-node-p"><code>has-node-p</code></a></li>
      <li><a href="#indegree"><code>indegree</code></a></li>
      <li><a href="#k-cores"><code>k-cores</code></a></li>
      <li><a href="#katz-centrality"><code>katz-centrality</code></a></li>
      <li><a href="#levels"><code>levels</code></a></li>
      <li><a href="#max-flow"><code>max-flow</code></a></li>
      <li><a href="#merge-edges"><code>merge-edges</code></a></li>
      <li><a href="#merge-nodes"><code>merge-nodes</code></a></li>
      <li><a href="#min-cut"><code>min-cut</code></a></li>
      <li><a href="#minimum-spanning-tree"><code>minimum-spanning-tree</code></a></li>
      <li><a href="#neighbors"><code>neighbors</code></a></li>
      <li><a href="#node-edges"><code>node-edges</code></a></li>
      <li><a href="#nodes"><code>nodes</code></a></li>
      <li><a href="#nodes-w-values"><code>nodes-w-values</code></a></li>
      <li><a href="#outdegree"><code>outdegree</code></a></li>
      <li><a href="#populate"><code>populate</code></a></li>
      <li><a href="#precedents"><code>precedents</code></a></li>
      <li><a href="#preferential-attachment-populate"><code>preferential-attachment-populate</code></a></li>
      <li><a href="#residual"><code>residual</code></a></li>
      <li><a href="#reverse-edges"><code>reverse-edges</code></a></li>
      <li><a href="#shortest-path"><code>shortest-path</code></a></li>
      <li><a href="#strongly-connected-components"><code>strongly-connected-components</code></a></li>
      <li><a href="#subgraph"><code>subgraph</code></a></li>
      <li><a href="#to-plist"><code>to-plist</code></a></li>
      <li><a href="#to-value-matrix"><code>to-value-matrix</code></a></li>
      <li><a href="#topological-sort"><code>topological-sort</code></a></li>
    </ol>
  <li><a href="#ack">Acknowledgements</a></li>
</ol>

<br>&nbsp;<br><h3><a class=none name="source">Source</a></h3>

GRAPH/GRAPH together with this documentation can be found at <a
href="http://github.com/eschulte/graph">http://github.com/eschulte/graph</a>.

<br>&nbsp;<br><h3><a class=none name="introduction">Introduction</a></h3>

<p>Graphs are composed of two hash tables, nodes and edges.  The node
hash is keyed by node and holds the edges containing that node,
while the edge hash is keyed by edge containing any optional edge
value.</p>

<pre><code>                         Nodes                  Edges
                        -------                -------
+----Graph G-----+     key |  value             key | value
|   3   2        |    -----+---------        -------+----------
| a---b---c   g  |       a |  (a b)           (a b) |  3
|    1|   |1     |       b |  (b d) (b c)     (b d) |  1
|     d---e---f  |       c |  (b c) (c e)     (b c) |  2
|       2   3    |       d |  (b d) (d e)     (c e) |  1
+----------------+       e |  (d e) (c e)     (d e) |  2
                         f |  (e f)           (e f) |  3
                         g |
</code></pre>

<p>Graphs are CLOS objects which are constructed with the usual <code>make
instance</code> and are populated with the <code>populate</code> function.</p>

<pre><code>(defvar *graph* (populate (make-instance 'graph)
                  :nodes '(a b c d e f g)
                  :edges-w-values '(((a b) . 3)
                                    ((b d) . 1)
                                    ((b c) . 2)
                                    ((c e) . 1)
                                    ((d e) . 2)
                                    ((e f) . 3))))
</code></pre>

<p>Standard accessors are provided.</p>

<pre><code>* (nodes *graph*)
(A B C D E F G)

* (edges *graph*)
((A B) (B D) (B C) (C E) (D E) (E F))

* (node-edges *graph* 'b)
((B C) (B D) (A B))

* (edge-value *graph* '(d e))
2
</code></pre>

<p>Nodes and edges may be removed using <code>delete-node</code> and
<code>delete-edge</code>, or using setf methods on any of the accessors above.</p>

<pre><code>* (delete-edge *graph* '(e f))
3

* (edges *graph*)
((A B) (B D) (B C) (C E) (D E))

* (setf (nodes *graph*) (remove 'a (nodes *graph*)))
(B C D E F G)

* (edges *graph*)
((B D) (B C) (C E) (D E))
</code></pre>

<p>Some more sophisticated graph algorithms are implemented.  A couple
are shown below, see the dictionary for a complete list.</p>

<pre><code>* (shortest-path *graph* 'b 'e)
((B C) (C E))

* (connected-components *graph*)
((G) (B D C E) (F))

* (setf (nodes *graph*) '(B D C E))
(B C D E)

* (min-cut *graph*)
((B C) (E D))
2
</code></pre>

<p>Additionally digraphs represent graphs with directed edges.
Starting with the original graph above we get the following.</p>

<pre><code>* (strongly-connected-components *graph*)
((G) (D F E C B A))

* (strongly-connected-components (digraph-of *graph*))
((G) (A) (B) (D) (C) (E) (F))

* (delete-edge *graph* '(d e))
2

* (push '(e d) (edges *graph*))
((A B) (B D) (B C) (C E) (E D) (E F))

* (push '(d c) (edges *graph*))
((A B) (B D) (B C) (C E) (E D) (E F) (D C))

* (strongly-connected-components (digraph-of *graph*))
((G) (A) (B) (D E C) (F))
</code></pre>

<br>&nbsp;<br><h3><a class=none name="dictionary">The GRAPH/GRAPH dictionary</a></h3>


<!-- Entry for ADD-EDGE -->

<p><br>[Generic function]<br><a class=none name='add-edge'><b>add-edge</b> <i>graph edge <tt>&amp;optional</tt> value</i> =&gt; <i>result</i></a>
<blockquote><br>

Add EDGE to GRAPH with optional VALUE. The nodes of
  EDGE are also added to GRAPH.




</blockquote>

<!-- End of entry for ADD-EDGE -->


<!-- Entry for ADD-NODE -->

<p><br>[Generic function]<br><a class=none name='add-node'><b>add-node</b> <i>graph node</i> =&gt; <i>result</i></a>
<blockquote><br>

Add NODE to GRAPH.




</blockquote>

<!-- End of entry for ADD-NODE -->


<!-- Entry for ADD-PATHS -->

<p><br>[Generic function]<br><a class=none name='add-paths'><b>add-paths</b> <i>graph path1 path2</i> =&gt; <i>result</i></a>
<blockquote><br>

Return the combination of paths PATH1 and PATH2 through GRAPH.
Each element of PATH has the form (cons edge value).




</blockquote>

<!-- End of entry for ADD-PATHS -->


<!-- Entry for BASIC-CYCLES -->

<p><br>[Generic function]<br><a class=none name='basic-cycles'><b>basic-cycles</b> <i>graph</i> =&gt; <i>result</i></a>
<blockquote><br>

Return all basic cycles in the GRAPH.




</blockquote>

<!-- End of entry for BASIC-CYCLES -->


<!-- Entry for BETWEENNESS -->

<p><br>[Generic function]<br><a class=none name='betweenness'><b>betweenness</b> <i>graph node</i> =&gt; <i>result</i></a>
<blockquote><br>

Fraction of shortest paths through GRAPH which pass through NODE.
Fraction of node pairs (s,t) s.t. s and t ≠ NODE and the shortest path
between s and t in GRAPH passes through NODE.




</blockquote>

<!-- End of entry for BETWEENNESS -->


<!-- Entry for CLIQUES -->

<p><br>[Generic function]<br><a class=none name='cliques'><b>cliques</b> <i>graph</i> =&gt; <i>result</i></a>
<blockquote><br>

Return the maximal cliques of GRAPH.
The Bron-Kerbosh algorithm is used.




</blockquote>

<!-- End of entry for CLIQUES -->


<!-- Entry for CLOSEDP -->

<p><br>[Generic function]<br><a class=none name='closedp'><b>closedp</b> <i>graph nodes</i> =&gt; <i>result</i></a>
<blockquote><br>

Return true if NODES are fully connected in GRAPH.




</blockquote>

<!-- End of entry for CLOSEDP -->


<!-- Entry for CLOSENESS -->

<p><br>[Generic function]<br><a class=none name='closeness'><b>closeness</b> <i>graph node</i> =&gt; <i>result</i></a>
<blockquote><br>

Inverse of the <code>farness</code> for NODE in GRAPH.




</blockquote>

<!-- End of entry for CLOSENESS -->


<!-- Entry for CLUSTERING-COEFFICIENT -->

<p><br>[Generic function]<br><a class=none name='clustering-coefficient'><b>clustering-coefficient</b> <i>graph</i> =&gt; <i>result</i></a>
<blockquote><br>

Fraction of connected triples which are closed.




</blockquote>

<!-- End of entry for CLUSTERING-COEFFICIENT -->


<!-- Entry for CONNECTED-COMPONENT -->

<p><br>[Generic function]<br><a class=none name='connected-component'><b>connected-component</b> <i>graph node <tt>&amp;key</tt> type</i> =&gt; <i>result</i></a>
<blockquote><br>

Return the connected component of NODE in GRAPH.
The TYPE keyword argument only has an effect for directed graphs in
which it may be set to one of the following with :STRONG being the
default value.

:STRONG ..... connections only traverse edges along the direction of
<pre>
              the edge
</pre>
:WEAK ....... connections may traverse edges in any direction
<pre>
              regardless of the edge direction
</pre>
:UNILATERAL . two nodes a and b connected iff a is strongly connected
<pre>
              to b or b is strongly connected to a
</pre>


</blockquote>

<!-- End of entry for CONNECTED-COMPONENT -->


<!-- Entry for CONNECTED-COMPONENTS -->

<p><br>[Generic function]<br><a class=none name='connected-components'><b>connected-components</b> <i>graph <tt>&amp;key</tt> type</i> =&gt; <i>result</i></a>
<blockquote><br>

Return a list of the connected components of GRAPH.
Keyword TYPE is passed to <code>connected-component</code> and only has effect
for directed graphs. Returns strongly connected components of a
directed graph by default.




</blockquote>

<!-- End of entry for CONNECTED-COMPONENTS -->


<!-- Entry for CONNECTED-GROUPS-OF-SIZE -->

<p><br>[Generic function]<br><a class=none name='connected-groups-of-size'><b>connected-groups-of-size</b> <i>graph size</i> =&gt; <i>result</i></a>
<blockquote><br>

Return all connected node groups of SIZE in GRAPH.




</blockquote>

<!-- End of entry for CONNECTED-GROUPS-OF-SIZE -->


<!-- Entry for CONNECTEDP -->

<p><br>[Generic function]<br><a class=none name='connectedp'><b>connectedp</b> <i>graph <tt>&amp;key</tt> type</i> =&gt; <i>result</i></a>
<blockquote><br>

Return true if the graph is connected.
TYPE keyword argument is passed to <code>connected-components</code>.




</blockquote>

<!-- End of entry for CONNECTEDP -->


<!-- Entry for COPY -->

<p><br>[Generic function]<br><a class=none name='copy'><b>copy</b> <i>graph</i> =&gt; <i>result</i></a>
<blockquote><br>

Return a copy of GRAPH.




</blockquote>

<!-- End of entry for COPY -->


<!-- Entry for CYCLES -->

<p><br>[Generic function]<br><a class=none name='cycles'><b>cycles</b> <i>graph</i> =&gt; <i>result</i></a>
<blockquote><br>

Return all cycles of GRAPH (both basic and compound).




</blockquote>

<!-- End of entry for CYCLES -->


<!-- Entry for DEGENERACY -->

<p><br>[Generic function]<br><a class=none name='degeneracy'><b>degeneracy</b> <i>graph</i> =&gt; <i>result</i></a>
<blockquote><br>

Return the degeneracy and k-cores of GRAPH.
Also return the node ordering with optimal coloring number as an
alist.  The <code>car</code> of each element of the alist identifies k-cores and
the <code>cdr</code> holds the nodes in the ordering.




</blockquote>

<!-- End of entry for DEGENERACY -->


<!-- Entry for DEGREE -->

<p><br>[Generic function]<br><a class=none name='degree'><b>degree</b> <i>graph node</i> =&gt; <i>result</i></a>
<blockquote><br>

Return the degree of NODE in GRAPH.




</blockquote>

<!-- End of entry for DEGREE -->


<!-- Entry for DELETE-EDGE -->

<p><br>[Generic function]<br><a class=none name='delete-edge'><b>delete-edge</b> <i>graph edge</i> =&gt; <i>result</i></a>
<blockquote><br>

Delete EDGE from GRAPH.
Return the old value of EDGE.




</blockquote>

<!-- End of entry for DELETE-EDGE -->


<!-- Entry for DELETE-NODE -->

<p><br>[Generic function]<br><a class=none name='delete-node'><b>delete-node</b> <i>graph node</i> =&gt; <i>result</i></a>
<blockquote><br>

Delete NODE from GRAPH.
Delete and return the old edges of NODE in GRAPH.




</blockquote>

<!-- End of entry for DELETE-NODE -->


<!-- Entry for DIGRAPH -->

<p><br>[Standard class]<br><a class=none name='digraph'><b>digraph</b></a>
<blockquote><br>

A <code>graph</code> with directed edges.




</blockquote>

<!-- End of entry for DIGRAPH -->


<!-- Entry for DIGRAPH-OF -->

<p><br>[Generic function]<br><a class=none name='digraph-of'><b>digraph-of</b> <i>graph</i> =&gt; <i>result</i></a>
<blockquote><br>

Copy GRAPH into a <code>digraph</code> and return.




</blockquote>

<!-- End of entry for DIGRAPH-OF -->


<!-- Entry for EDGAR-GILBERT-DIGRAPH -->

<p><br>[Function]<br><a class=none name='edgar-gilbert-digraph'><b>edgar-gilbert-digraph</b> <i>n p</i> =&gt; <i>result</i></a>
<blockquote><br>



</blockquote>

<!-- End of entry for EDGAR-GILBERT-DIGRAPH -->


<!-- Entry for EDGAR-GILBERT-GRAPH -->

<p><br>[Function]<br><a class=none name='edgar-gilbert-graph'><b>edgar-gilbert-graph</b> <i>n p</i> =&gt; <i>result</i></a>
<blockquote><br>



</blockquote>

<!-- End of entry for EDGAR-GILBERT-GRAPH -->


<!-- Entry for EDGAR-GILBERT-POPULATE -->

<p><br>[Generic function]<br><a class=none name='edgar-gilbert-populate'><b>edgar-gilbert-populate</b> <i>graph p</i> =&gt; <i>result</i></a>
<blockquote><br>

Populate GRAPH including every possible edge with probability P.




</blockquote>

<!-- End of entry for EDGAR-GILBERT-POPULATE -->


<!-- Entry for EDGE-NEIGHBORS -->

<p><br>[Generic function]<br><a class=none name='edge-neighbors'><b>edge-neighbors</b> <i>graph edge</i> =&gt; <i>result</i></a>
<blockquote><br>

Return all edges which share a node with EDGE in GRAPH.




</blockquote>

<!-- End of entry for EDGE-NEIGHBORS -->


<!-- Entry for EDGE-VALUE -->

<p><br>[Generic accessor]<br><a class=none name='edge-value'><b>edge-value</b> <i>graph edge</i> =&gt; <i>result</i></a>
<br><a class=none><tt>(setf (</tt><b>edge-value</b> <i>graph edge</i><tt>)</tt> <i>new</i><tt>)</tt></a>
<blockquote><br>

Return the value of EDGE in GRAPH.




</blockquote>

<!-- End of entry for EDGE-VALUE -->


<!-- Entry for EDGES -->

<p><br>[Generic accessor]<br><a class=none name='edges'><b>edges</b> <i>graph</i> =&gt; <i>result</i></a>
<br><a class=none><tt>(setf (</tt><b>edges</b> <i>graph</i><tt>)</tt> <i>new</i><tt>)</tt></a>
<blockquote><br>

Return a list of the edges in GRAPH.




</blockquote>

<!-- End of entry for EDGES -->


<!-- Entry for EDGES-W-VALUES -->

<p><br>[Generic accessor]<br><a class=none name='edges-w-values'><b>edges-w-values</b> <i>graph</i> =&gt; <i>result</i></a>
<br><a class=none><tt>(setf (</tt><b>edges-w-values</b> <i>graph</i><tt>)</tt> <i>new</i><tt>)</tt></a>
<blockquote><br>

Return an alist of edges of GRAPH with their values.




</blockquote>

<!-- End of entry for EDGES-W-VALUES -->


<!-- Entry for ERDOS-RENYI-DIGRAPH -->

<p><br>[Function]<br><a class=none name='erdos-renyi-digraph'><b>erdos-renyi-digraph</b> <i>n m</i> =&gt; <i>result</i></a>
<blockquote><br>

Return an Erdős–Rényi digraph with N nodes and M edges.




</blockquote>

<!-- End of entry for ERDOS-RENYI-DIGRAPH -->


<!-- Entry for ERDOS-RENYI-GRAPH -->

<p><br>[Function]<br><a class=none name='erdos-renyi-graph'><b>erdos-renyi-graph</b> <i>n m</i> =&gt; <i>result</i></a>
<blockquote><br>

Return an Erdős–Rényi graph with N nodes and M edges.




</blockquote>

<!-- End of entry for ERDOS-RENYI-GRAPH -->


<!-- Entry for ERDOS-RENYI-POPULATE -->

<p><br>[Generic function]<br><a class=none name='erdos-renyi-populate'><b>erdos-renyi-populate</b> <i>graph m</i> =&gt; <i>result</i></a>
<blockquote><br>

Populate GRAPH with M edges in an Erdős–Rényi random graph model.




</blockquote>

<!-- End of entry for ERDOS-RENYI-POPULATE -->


<!-- Entry for FARNESS -->

<p><br>[Generic function]<br><a class=none name='farness'><b>farness</b> <i>graph node</i> =&gt; <i>result</i></a>
<blockquote><br>

Sum of the distance from NODE to every other node in connected GRAPH.




</blockquote>

<!-- End of entry for FARNESS -->


<!-- Entry for FROM-PLIST -->

<p><br>[Generic function]<br><a class=none name='from-plist'><b>from-plist</b> <i>graph plist</i> =&gt; <i>result</i></a>
<blockquote><br>

Populate GRAPH with the contents of PLIST.




</blockquote>

<!-- End of entry for FROM-PLIST -->


<!-- Entry for FROM-VALUE-MATRIX -->

<p><br>[Generic function]<br><a class=none name='from-value-matrix'><b>from-value-matrix</b> <i>graph matrix</i> =&gt; <i>result</i></a>
<blockquote><br>

Populate GRAPH from the value matrix MATRIX.




</blockquote>

<!-- End of entry for FROM-VALUE-MATRIX -->


<!-- Entry for GRAPH -->

<p><br>[Standard class]<br><a class=none name='graph'><b>graph</b></a>
<blockquote><br>

A graph consisting of <code>nodes</code> connected by <code>edges</code>.
Nodes must be numbers symbols or keywords.  Edges may be assigned
arbitrary values, although some functions assume numeric values (e.g.,
<code>merge-nodes</code>, <code>merge-edges</code>, <code>max-flow</code> and <code>min-cut</code>).




</blockquote>

<!-- End of entry for GRAPH -->


<!-- Entry for GRAPH-EQUAL -->

<p><br>[Generic function]<br><a class=none name='graph-equal'><b>graph-equal</b> <i>graph1 graph2</i> =&gt; <i>result</i></a>
<blockquote><br>

Compare GRAPH1 and GRAPH2 for equality.




</blockquote>

<!-- End of entry for GRAPH-EQUAL -->


<!-- Entry for GRAPH-OF -->

<p><br>[Generic function]<br><a class=none name='graph-of'><b>graph-of</b> <i>digraph</i> =&gt; <i>result</i></a>
<blockquote><br>

Copy DIGRAPH into a <code>graph</code> and return.




</blockquote>

<!-- End of entry for GRAPH-OF -->


<!-- Entry for HAS-EDGE-P -->

<p><br>[Generic function]<br><a class=none name='has-edge-p'><b>has-edge-p</b> <i>graph edge</i> =&gt; <i>result</i></a>
<blockquote><br>

Return <code>true</code> if GRAPH has edge EDGE.




</blockquote>

<!-- End of entry for HAS-EDGE-P -->


<!-- Entry for HAS-NODE-P -->

<p><br>[Generic function]<br><a class=none name='has-node-p'><b>has-node-p</b> <i>graph node</i> =&gt; <i>result</i></a>
<blockquote><br>

Return <code>true</code> if GRAPH has node NODE.




</blockquote>

<!-- End of entry for HAS-NODE-P -->


<!-- Entry for INDEGREE -->

<p><br>[Generic function]<br><a class=none name='indegree'><b>indegree</b> <i>digraph node</i> =&gt; <i>result</i></a>
<blockquote><br>

The number of edges directed to NODE in GRAPH.




</blockquote>

<!-- End of entry for INDEGREE -->


<!-- Entry for K-CORES -->

<p><br>[Generic function]<br><a class=none name='k-cores'><b>k-cores</b> <i>graph</i> =&gt; <i>result</i></a>
<blockquote><br>

Return the k-cores of GRAPH.




</blockquote>

<!-- End of entry for K-CORES -->


<!-- Entry for KATZ-CENTRALITY -->

<p><br>[Generic function]<br><a class=none name='katz-centrality'><b>katz-centrality</b> <i>graph node <tt>&amp;key</tt> attenuation</i> =&gt; <i>result</i></a>
<blockquote><br>

Combined measure of number and nearness of nodes to NODE.




</blockquote>

<!-- End of entry for KATZ-CENTRALITY -->


<!-- Entry for LEVELS -->

<p><br>[Generic function]<br><a class=none name='levels'><b>levels</b> <i>digraph <tt>&amp;key</tt> alist</i> =&gt; <i>result</i></a>
<blockquote><br>

Assign a positive integer to each node in DIGRAPH,
called its level, where, for each directed edge (a b) the
corresponding integers satisfy a < b. Returns either a hash table
where the nodes are keys and the levels are values, or an association
list of nodes and their levels, along with the number of levels in
DIGRAPH.




</blockquote>

<!-- End of entry for LEVELS -->


<!-- Entry for MAX-FLOW -->

<p><br>[Generic function]<br><a class=none name='max-flow'><b>max-flow</b> <i>graph from to</i> =&gt; <i>result</i></a>
<blockquote><br>

Return the maximum flow from FROM and TO in GRAPH.
GRAPHS must be a network with numeric values of all edges.
The Ford-Fulkerson algorithm is used.




</blockquote>

<!-- End of entry for MAX-FLOW -->


<!-- Entry for MERGE-EDGES -->

<p><br>[Generic function]<br><a class=none name='merge-edges'><b>merge-edges</b> <i>graph edge1 edge2 <tt>&amp;key</tt> value</i> =&gt; <i>result</i></a>
<blockquote><br>

Combine EDGE1 and EDGE2 in GRAPH into a new EDGE.
Optionally provide a value for the new edge, the values of EDGE1 and
EDGE2 will be combined.




</blockquote>

<!-- End of entry for MERGE-EDGES -->


<!-- Entry for MERGE-NODES -->

<p><br>[Generic function]<br><a class=none name='merge-nodes'><b>merge-nodes</b> <i>graph node1 node2 <tt>&amp;key</tt> new</i> =&gt; <i>result</i></a>
<blockquote><br>

Combine NODE1 and NODE2 in GRAPH into the node NEW.
All edges of NODE1 and NODE2 in GRAPH will be combined into a new node
of value NEW.  Edges between only NODE1 and NODE2 will be removed.




</blockquote>

<!-- End of entry for MERGE-NODES -->


<!-- Entry for MIN-CUT -->

<p><br>[Generic function]<br><a class=none name='min-cut'><b>min-cut</b> <i>graph</i> =&gt; <i>result</i></a>
<blockquote><br>

Return both the global min-cut of GRAPH and the weight of the cut.




</blockquote>

<!-- End of entry for MIN-CUT -->


<!-- Entry for MINIMUM-SPANNING-TREE -->

<p><br>[Generic function]<br><a class=none name='minimum-spanning-tree'><b>minimum-spanning-tree</b> <i>graph <tt>&amp;optional</tt> tree</i> =&gt; <i>result</i></a>
<blockquote><br>

Return a minimum spanning tree of GRAPH.
Prim's algorithm is used.  Optional argument TREE may be used to
specify an initial tree, otherwise a random node is used.




</blockquote>

<!-- End of entry for MINIMUM-SPANNING-TREE -->


<!-- Entry for NEIGHBORS -->

<p><br>[Generic function]<br><a class=none name='neighbors'><b>neighbors</b> <i>graph node</i> =&gt; <i>result</i></a>
<blockquote><br>

Return all nodes which share an edge with NODE in GRAPH.




</blockquote>

<!-- End of entry for NEIGHBORS -->


<!-- Entry for NODE-EDGES -->

<p><br>[Generic accessor]<br><a class=none name='node-edges'><b>node-edges</b> <i>graph node</i> =&gt; <i>result</i></a>
<br><a class=none><tt>(setf (</tt><b>node-edges</b> <i>graph node</i><tt>)</tt> <i>new</i><tt>)</tt></a>
<blockquote><br>

Return the value of NODE in GRAPH.




</blockquote>

<!-- End of entry for NODE-EDGES -->


<!-- Entry for NODES -->

<p><br>[Generic accessor]<br><a class=none name='nodes'><b>nodes</b> <i>graph</i> =&gt; <i>result</i></a>
<br><a class=none><tt>(setf (</tt><b>nodes</b> <i>graph</i><tt>)</tt> <i>new</i><tt>)</tt></a>
<blockquote><br>

Return a list of the nodes in GRAPH.




</blockquote>

<!-- End of entry for NODES -->


<!-- Entry for NODES-W-VALUES -->

<p><br>[Generic function]<br><a class=none name='nodes-w-values'><b>nodes-w-values</b> <i>graph</i> =&gt; <i>result</i></a>
<blockquote><br>

Return an alist of nodes of GRAPH with their values.




</blockquote>

<!-- End of entry for NODES-W-VALUES -->


<!-- Entry for OUTDEGREE -->

<p><br>[Generic function]<br><a class=none name='outdegree'><b>outdegree</b> <i>digraph node</i> =&gt; <i>result</i></a>
<blockquote><br>

The number of edges directed from NODE in DIGRAPH.




</blockquote>

<!-- End of entry for OUTDEGREE -->


<!-- Entry for POPULATE -->

<p><br>[Generic function]<br><a class=none name='populate'><b>populate</b> <i>graph <tt>&amp;key</tt> nodes edges edges-w-values</i> =&gt; <i>result</i></a>
<blockquote><br>

Populate the nodes and edges of GRAPH based on keyword arguments.




</blockquote>

<!-- End of entry for POPULATE -->


<!-- Entry for PRECEDENTS -->

<p><br>[Generic function]<br><a class=none name='precedents'><b>precedents</b> <i>digraph node</i> =&gt; <i>result</i></a>
<blockquote><br>

Return all nodes preceding NODE in an edge of DIGRAPH.




</blockquote>

<!-- End of entry for PRECEDENTS -->


<!-- Entry for PREFERENTIAL-ATTACHMENT-POPULATE -->

<p><br>[Generic function]<br><a class=none name='preferential-attachment-populate'><b>preferential-attachment-populate</b> <i>graph nodes <tt>&amp;key</tt> edge-vals</i> =&gt; <i>result</i></a>
<blockquote><br>

Add NODES to GRAPH using preferential attachment, return the new edges.
Optionally assign edge values from those listed in EDGE-VALS.




</blockquote>

<!-- End of entry for PREFERENTIAL-ATTACHMENT-POPULATE -->


<!-- Entry for RESIDUAL -->

<p><br>[Generic function]<br><a class=none name='residual'><b>residual</b> <i>graph flow</i> =&gt; <i>result</i></a>
<blockquote><br>

Return the residual graph of GRAPH with FLOW.
Each edge in the residual has a value equal to the original capacity
minus the current flow, or equal to the negative of the current flow.




</blockquote>

<!-- End of entry for RESIDUAL -->


<!-- Entry for REVERSE-EDGES -->

<p><br>[Generic function]<br><a class=none name='reverse-edges'><b>reverse-edges</b> <i>graph</i> =&gt; <i>result</i></a>
<blockquote><br>

Return a copy of GRAPH with all edges reversed.




</blockquote>

<!-- End of entry for REVERSE-EDGES -->


<!-- Entry for SHORTEST-PATH -->

<p><br>[Generic function]<br><a class=none name='shortest-path'><b>shortest-path</b> <i>graph a b</i> =&gt; <i>result</i></a>
<blockquote><br>

Return the shortest path in GRAPH from A to B.
GRAPH must be a directed graph.  Dijkstra's algorithm is used.




</blockquote>

<!-- End of entry for SHORTEST-PATH -->


<!-- Entry for STRONGLY-CONNECTED-COMPONENTS -->

<p><br>[Generic function]<br><a class=none name='strongly-connected-components'><b>strongly-connected-components</b> <i>graph</i> =&gt; <i>result</i></a>
<blockquote><br>

Return the nodes of GRAPH partitioned into strongly connected components.
Uses Tarjan's algorithm.




</blockquote>

<!-- End of entry for STRONGLY-CONNECTED-COMPONENTS -->


<!-- Entry for SUBGRAPH -->

<p><br>[Generic function]<br><a class=none name='subgraph'><b>subgraph</b> <i>graph nodes</i> =&gt; <i>result</i></a>
<blockquote><br>

Return the subgraph of GRAPH restricted to NODES.




</blockquote>

<!-- End of entry for SUBGRAPH -->


<!-- Entry for TO-PLIST -->

<p><br>[Generic function]<br><a class=none name='to-plist'><b>to-plist</b> <i>graph <tt>&amp;key</tt> node-fn edge-fn</i> =&gt; <i>result</i></a>
<blockquote><br>

Serialize GRAPH as a plist.
Keyword arguments NODE-FN and EDGE-FN will be called on a node or edge
and should return a plist of data to associate with the given node or
edge in the results.




</blockquote>

<!-- End of entry for TO-PLIST -->


<!-- Entry for TO-VALUE-MATRIX -->

<p><br>[Generic function]<br><a class=none name='to-value-matrix'><b>to-value-matrix</b> <i>graph</i> =&gt; <i>result</i></a>
<blockquote><br>

Return the value matrix of GRAPH.




</blockquote>

<!-- End of entry for TO-VALUE-MATRIX -->


<!-- Entry for TOPOLOGICAL-SORT -->

<p><br>[Generic function]<br><a class=none name='topological-sort'><b>topological-sort</b> <i>digraph</i> =&gt; <i>result</i></a>
<blockquote><br>

Returns a topologically ordered list of the nodes in DIGRAPH, such
   that, for each edge in DIGRAPH, the start of the edge appears in the
   list before the end of the edge.




</blockquote>

<!-- End of entry for TOPOLOGICAL-SORT -->


<br>&nbsp;<br><h3><a class=none name="ack">Acknowledgements</a></h3>

<p>
This documentation was prepared with a hacked up version of <a href="http://weitz.de/documentation-template/">DOCUMENTATION-TEMPLATE</a>.
</p>

</body>
</html>